- import pandas as pd
- from sklearn.model_selection import train_test_split
- from sklearn.ensemble import RandomForestClassifier
- from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
- from google.colab import files
- uploaded = files.upload()\
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
- 세로 : index / 가로 : column

- isnull : NULL의 값을 True or False 로 표현해줌
- isnull().sum() : null의 갯수 파악
- notnull : isnull의 반대 
- dropna : 
- fillna : NULL 값을 fillna() 괄호 안에 있는 값으로 대체함.
- drop : 삭제 
- set_index :  
- reset_index :
- transpose : 전치 / 뒤에.T 붙이면댐 

- values, to_numpy() : 배열 
- tolist() : 리스트
- to_dict() : 딕셔너리 

- iloc[index, column] : 각 index / column의 번호를 기입. ( Ex > iloc[0: , 2] , iloc[2, 1:3] )
- loc[index, column] : [index 제목, column 제목] ( 문자로 표현 시 '' 기입)

- df.index.name = None : column 값이 없는 인덱스를 제거 

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
#### axis = 1 → 행방향으로 정렬 
#### axis = 0 → 열방향으로 정렬
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
#### 문자열 → datetime 형식으로 변환
- pd.to_datetime(date_str)

#### datetime → 문자열 형식으로 변환
- [date.strftime('%Y-%m-%d') for date in date_objects]

#### 일정한 간격으로 날짜 생성  
- pd.date_range(start = '2022-01-01', end = '2022-01-10')

#### 날짜 범위 슬라이싱
print(df['2022-01-01':'2022-01-02'])

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
# datetime vs. Timestamp
- datetime 은 phthon 표준 라이브러리에서 제공
- Timestamp 는 pandas 라이브러리에서 제공
- Timestamp 는 pandas의 다른 데이터 구조와의 호환성이 좋으며, 사계열 데이터를 다룰 때 유리
- Timestamp 는 datetime 객체의 기능을 확장하여 시계열 분석에 필요한 추가 기능을 제공\
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
#### Pandas는 주어진 주기(일, 월, 분기 등)에 따라 데이터를 리샘플링 할 수 있는 기능을 제공 
date_range = pd.date_range(start = '2020-01-01', periods = 10, freq = 'D')
data = {'value':range(10)}
df = pd.DataFrame(data, index = date_range)
print(df, '\n')

#### 월별 데이터 합계 계산
1. monthly_sum = df.resample('M').sum()
print(monthly_sum)

2. df = pd.DataFrame({
    'date': ['2022-01-01', '2022-01-15', '2022-02-01', '2022-02-15', '2022-03-01'],
    'value': [1, 2, 3, 4, 5]
})
df['month'] = df['date'].dt.to_period('M')
monthly_sum = df.groupby('month')['value'].sum().reset_index()

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

#### Pandas의 datetime 형식 데이터는 다양한 속성에 접근할 수 있다. 
#### 예를 들어, 연도, 월, 일, 요일 등을 쉽게 추출

df['year'] = df.index.year
df['month'] = df.index.month
df['day'] = df.index.day
df['day_of_week'] = df.index.dayofweek

#### df의 날짜 리스트를 datetime 형식으로 변환
df['New_Date'] = pd.to_datetime(df['date'])

#### 변환된 데이터 프레임의 년도, 월, 일 Columns를 추가
df['Year'] = df['New_Date'].dt.year
df['Month'] = df['New_Date'].dt.month
df['Day'] = df['New_Date'].dt.day
df['day_of_week'] = df['New_Date'].dt.dayofweek

#### 분기별 데이터로 변환:
/ resample('Q')를 사용하여 데이터를 분기별로 그룹화합니다.
/ max()를 사용하여 각 분기 내의 마지막 날짜를 선택합니다. 이는 분기별로 가장 큰 날짜(즉, 각 분기의 마지막 날)를 선택하는 방식입니다.

#### index_col = 0 
- index_col = 0은 어떤 함수를 사용할 때 지정된 열(column)을 DataFrame의 인덱스로 사용하겠다는 의미. 
- 여기서 0은 CSV 파일의 첫 번째 열을 가리킵니다. 
- 예를 들어, CSV 파일의 첫 번째 열이 고유 식별자나 특정 인덱스를 포함하고 있다면, 이 열을 DataFrame의 인덱스로 사용하게 됩니다.

#### reset_index()
- DataFrame의 인덱스를 기본 정수형 인덱스로 재설정하는 인덱스 
→ 기존의 인덱스를 제거 후 0부터 시작하는 새 인덱스를 생성하는 것 .
/ 괄호 안에 drop=True를 넣게 되면 새 인덱스는 생성되지 않음 / 

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
#### np.empty((행 갯수, 열 갯수))
- 빈 공간만 만들고 값은 없는 상태의 배열을 만들 수 있음. 

#### 1차원, 2차원, 3차원으로 바꾸는 법
- 1차원 : 함수명.reshape(-1)
- 2차원 : 함수명.reshape(n, -1)
- 3차원 : 함수명.reshape(-1, m, n)

#### np.where(arr > 0, 1, -1)
- arr > 0의 조건을 만족하면 1으로 반환하는 함수
- arr > 0의 조건을 만족하지 않으면 -1로 반환하는 함수

#### n번째 요소의 인덱스 구하기
- np.unravel_index(n, array_shape)

#### 크기를 이미 정한 배열에서 더 큰 배열로 늘릴 때
- np.pad(만든배열, pad_width = 늘릴 칸 수 , mode = 'constant', constant_values = 0)
















